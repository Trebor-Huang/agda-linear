module Pattern where

open import Types

-- What defines a type is the patterns.
-- Positive types are defined by patterns that constructs its values.
-- Negative types are defined by patterns that specifies its continuation.

-- Patterns do not contain binding-related information.
-- For instance, ‚ü® $ , œñ‚ÇÅ $ ‚ü© is what we usually write as (in Haskell)
-- ( x, Left y ). we use $ as placeholders for pattern variables.
-- This makes a lot of operations on binding structures easier.
-- I will write a separate article on this.

-- A subtlety: The last five patterns are all placeholders for variables.
-- However, apart from $, the other four are 'atomic' variables
-- that we allow. $ signifies 'shallow' pattern matching.

data Pattern : T -> Set where
    ‚ü®_,_‚ü© : ‚àÄ {A‚Å∫ B‚Å∫} -> Pattern (‚óã A‚Å∫) -> Pattern (‚óã B‚Å∫) -> Pattern (‚óã A‚Å∫ ‚äó B‚Å∫)
    œñ‚ÇÅ : ‚àÄ {A‚Å∫ B‚Å∫} -> Pattern (‚óã A‚Å∫) -> Pattern (‚óã A‚Å∫ ‚äï B‚Å∫)
    œñ‚ÇÇ : ‚àÄ {A‚Å∫ B‚Å∫} -> Pattern (‚óã B‚Å∫) -> Pattern (‚óã A‚Å∫ ‚äï B‚Å∫)
    ‚ü™_,_‚ü´ : ‚àÄ {A‚Åª B‚Åª} -> Pattern (‚óè A‚Åª) -> Pattern (‚óè B‚Åª) -> Pattern (‚óè A‚Åª ‚Öã B‚Åª)
    œÄ‚ÇÅ : ‚àÄ {A‚Åª B‚Åª} -> Pattern (‚óè A‚Åª) -> Pattern (‚óè A‚Åª & B‚Åª)
    œÄ‚ÇÇ : ‚àÄ {A‚Åª B‚Åª} -> Pattern (‚óè B‚Åª) -> Pattern (‚óè A‚Åª & B‚Åª)
    *ÃÇ : Pattern (‚óã ùüô)
    *Ã¨ : Pattern (‚óè ‚ä•)
    ‚áë : ‚àÄ A‚Å∫ -> Pattern (‚óã ‚Üë A‚Å∫)
    ‚áì : ‚àÄ A‚Åª -> Pattern (‚óè ‚Üì A‚Åª)
    ‚óè‚Å∫ : ‚àÄ A‚Å∫ -> Pattern (‚óã ¬¨‚Å∫ A‚Å∫)
    ‚óè‚Åª : ‚àÄ A‚Åª -> Pattern (‚óè ¬¨‚Åª A‚Åª)
    $ : ‚àÄ t -> Pattern t

infix 6 _‚àã‚Çö_
-- We turn to define de Bruijn indices.
-- Note that it is not just unary numbers, but a structured type.
-- This is because the patterns have structures, and we want to respect them.

-- This is just a zipper on Patterns.
data _‚àã‚Çö_ : ‚àÄ {A} -> Pattern A -> T -> Set where
    ‚ü®_,~‚ü© : ‚àÄ {A‚Å∫ B‚Å∫ t} {p : Pattern (‚óã A‚Å∫)} {q : Pattern (‚óã B‚Å∫)} -> p ‚àã‚Çö t -> ‚ü® p , q ‚ü© ‚àã‚Çö t
    ‚ü®~,_‚ü© : ‚àÄ {A‚Å∫ B‚Å∫ t} {p : Pattern (‚óã A‚Å∫)} {q : Pattern (‚óã B‚Å∫)} -> q ‚àã‚Çö t -> ‚ü® p , q ‚ü© ‚àã‚Çö t
    ~œñ‚ÇÅ : ‚àÄ {A‚Å∫ B‚Å∫ t} {p : Pattern (‚óã A‚Å∫)} -> p ‚àã‚Çö t -> œñ‚ÇÅ {B‚Å∫ = B‚Å∫} p ‚àã‚Çö t
    ~œñ‚ÇÇ : ‚àÄ {A‚Å∫ B‚Å∫ t} {p : Pattern (‚óã B‚Å∫)} -> p ‚àã‚Çö t -> œñ‚ÇÇ {A‚Å∫ = A‚Å∫} p ‚àã‚Çö t
    ‚ü™_,~‚ü´ : ‚àÄ {A‚Åª B‚Åª t} {p : Pattern (‚óè A‚Åª)} {q : Pattern (‚óè B‚Åª)} -> p ‚àã‚Çö t -> ‚ü™ p , q ‚ü´ ‚àã‚Çö t
    ‚ü™~,_‚ü´ : ‚àÄ {A‚Åª B‚Åª t} {p : Pattern (‚óè A‚Åª)} {q : Pattern (‚óè B‚Åª)} -> q ‚àã‚Çö t -> ‚ü™ p , q ‚ü´ ‚àã‚Çö t
    ~œÄ‚ÇÅ : ‚àÄ {A‚Åª B‚Åª t} {p : Pattern (‚óè A‚Åª)} -> p ‚àã‚Çö t -> œÄ‚ÇÅ {B‚Åª = B‚Åª} p ‚àã‚Çö t
    ~œÄ‚ÇÇ : ‚àÄ {A‚Åª B‚Åª t} {p : Pattern (‚óè B‚Åª)} -> p ‚àã‚Çö t -> œÄ‚ÇÇ {A‚Åª = A‚Åª} p ‚àã‚Çö t
    ~‚áë : ‚àÄ {A‚Å∫} -> ‚áë A‚Å∫ ‚àã‚Çö ‚óè A‚Å∫
    ~‚áì : ‚àÄ {A‚Åª} -> ‚áì A‚Åª ‚àã‚Çö ‚óã A‚Åª
    ~‚óè‚Å∫ : ‚àÄ {A‚Å∫} -> ‚óè‚Å∫ A‚Å∫ ‚àã‚Çö ‚óè A‚Å∫
    ~‚óè‚Åª : ‚àÄ {A‚Åª} -> ‚óè‚Åª A‚Åª ‚àã‚Çö ‚óã A‚Åª  -- Subtlety: ‚óã and ‚óè are not reflected in the syntax for ‚àã‚Çö.
    ~$ : ‚àÄ {t} -> $ t ‚àã‚Çö t

-- We check for pattern coverage, and deepness (i.e. whether the pattern uses $)
infix 9 _‚âª‚Çö_  -- p ‚âª‚Çö q denotes that the pattern p is more general than q.

data _‚âª‚Çö_ : ‚àÄ {A} -> Pattern A -> Pattern A -> Set where
    ‚âª$ : ‚àÄ {t} (p : Pattern t) -> $ t ‚âª‚Çö p
    -- The rest of these are boilerplate.
    ‚âª‚ü®_,_‚ü© : ‚àÄ {A‚Å∫ B‚Å∫} {p‚ÇÅ p‚ÇÇ : Pattern (‚óã A‚Å∫)} {q‚ÇÅ q‚ÇÇ : Pattern (‚óã B‚Å∫)}
        -> p‚ÇÅ ‚âª‚Çö p‚ÇÇ -> q‚ÇÅ ‚âª‚Çö q‚ÇÇ -> ‚ü® p‚ÇÅ , q‚ÇÅ ‚ü© ‚âª‚Çö ‚ü® p‚ÇÇ , q‚ÇÇ ‚ü©
    ‚âªœñ‚ÇÅ : ‚àÄ {A‚Å∫ B‚Å∫} {p‚ÇÅ p‚ÇÇ : Pattern (‚óã A‚Å∫)}
        -> p‚ÇÅ ‚âª‚Çö p‚ÇÇ -> œñ‚ÇÅ {B‚Å∫ = B‚Å∫} p‚ÇÅ ‚âª‚Çö œñ‚ÇÅ {B‚Å∫ = B‚Å∫} p‚ÇÇ
    ‚âªœñ‚ÇÇ : ‚àÄ {A‚Å∫ B‚Å∫} {p‚ÇÅ p‚ÇÇ : Pattern (‚óã B‚Å∫)}
        -> p‚ÇÅ ‚âª‚Çö p‚ÇÇ -> œñ‚ÇÇ {A‚Å∫ = A‚Å∫} p‚ÇÅ ‚âª‚Çö œñ‚ÇÇ {A‚Å∫ = A‚Å∫} p‚ÇÇ
    ‚âª‚ü™_,_‚ü´ : ‚àÄ {A‚Åª B‚Åª} {p‚ÇÅ p‚ÇÇ : Pattern (‚óè A‚Åª)} {q‚ÇÅ q‚ÇÇ : Pattern (‚óè B‚Åª)}
        -> p‚ÇÅ ‚âª‚Çö p‚ÇÇ -> q‚ÇÅ ‚âª‚Çö q‚ÇÇ -> ‚ü™ p‚ÇÅ , q‚ÇÅ ‚ü´ ‚âª‚Çö ‚ü™ p‚ÇÇ , q‚ÇÇ ‚ü´
    ‚âªœÄ‚ÇÅ : ‚àÄ {A‚Åª B‚Åª} {p‚ÇÅ p‚ÇÇ : Pattern (‚óè A‚Åª)}
        -> p‚ÇÅ ‚âª‚Çö p‚ÇÇ -> œÄ‚ÇÅ {B‚Åª = B‚Åª} p‚ÇÅ ‚âª‚Çö œÄ‚ÇÅ {B‚Åª = B‚Åª} p‚ÇÇ
    ‚âªœÄ‚ÇÇ : ‚àÄ {A‚Åª B‚Åª} {p‚ÇÅ p‚ÇÇ : Pattern (‚óè B‚Åª)}
        -> p‚ÇÅ ‚âª‚Çö p‚ÇÇ -> œÄ‚ÇÇ {A‚Åª = A‚Åª} p‚ÇÅ ‚âª‚Çö œÄ‚ÇÇ {A‚Åª = A‚Åª} p‚ÇÇ
    ‚âª‚áë : ‚àÄ {A‚Å∫} -> ‚áë A‚Å∫ ‚âª‚Çö ‚áë A‚Å∫
    ‚âª‚áì : ‚àÄ {A‚Åª} -> ‚áì A‚Åª ‚âª‚Çö ‚áì A‚Åª
    ‚âª‚óè‚Å∫ : ‚àÄ {A‚Å∫} -> ‚óè‚Å∫ A‚Å∫ ‚âª‚Çö ‚óè‚Å∫ A‚Å∫
    ‚âª‚óè‚Åª : ‚àÄ {A‚Åª} -> ‚óè‚Åª A‚Åª ‚âª‚Çö ‚óè‚Åª A‚Åª
    ‚âª*ÃÇ : *ÃÇ ‚âª‚Çö *ÃÇ
    ‚âª*Ã¨ : *Ã¨ ‚âª‚Çö *Ã¨

data $Ã∏ : ‚àÄ {t} -> Pattern t -> Set where
    -- No clause for $Ã∏$ because it's not deep.
    -- Otherwise we just recurse down the pattern.
    $Ã∏‚ü®_,_‚ü© : ‚àÄ {A‚Å∫ B‚Å∫} {p : Pattern (‚óã A‚Å∫)} {q : Pattern (‚óã B‚Å∫)}
        -> $Ã∏ p -> $Ã∏ q -> $Ã∏ ‚ü® p , q ‚ü©
    $Ã∏œñ‚ÇÅ : ‚àÄ {A‚Å∫ B‚Å∫} {p : Pattern (‚óã A‚Å∫)}
        -> $Ã∏ p -> $Ã∏ (œñ‚ÇÅ {B‚Å∫ = B‚Å∫} p)
    $Ã∏œñ‚ÇÇ : ‚àÄ {A‚Å∫ B‚Å∫} {p : Pattern (‚óã B‚Å∫)}
        -> $Ã∏ p -> $Ã∏ (œñ‚ÇÇ {A‚Å∫ = A‚Å∫} p)
    $Ã∏‚ü™_,_‚ü´ : ‚àÄ {A‚Åª B‚Åª} {p : Pattern (‚óè A‚Åª)} {q : Pattern (‚óè B‚Åª)}
        -> $Ã∏ p -> $Ã∏ q -> $Ã∏ ‚ü™ p , q ‚ü´
    $Ã∏œÄ‚ÇÅ : ‚àÄ {A‚Åª B‚Åª} {p : Pattern (‚óè A‚Åª)}
        -> $Ã∏ p -> $Ã∏ (œÄ‚ÇÅ {B‚Åª = B‚Åª} p)
    $Ã∏œÄ‚ÇÇ : ‚àÄ {A‚Åª B‚Åª} {p : Pattern (‚óè B‚Åª)}
        -> $Ã∏ p -> $Ã∏ (œÄ‚ÇÇ {A‚Åª = A‚Åª} p)
    $Ã∏*ÃÇ : $Ã∏ *ÃÇ
    $Ã∏*Ã¨ : $Ã∏ *Ã¨
    $Ã∏‚áë : ‚àÄ {A‚Å∫} -> $Ã∏ (‚áë A‚Å∫)
    $Ã∏‚áì : ‚àÄ {A‚Åª} -> $Ã∏ (‚áì A‚Åª)
    $Ã∏‚óè‚Å∫ : ‚àÄ {A‚Å∫} -> $Ã∏ (‚óè‚Å∫ A‚Å∫)
    $Ã∏‚óè‚Åª : ‚àÄ {A‚Åª} -> $Ã∏ (‚óè‚Åª A‚Åª)

-- A list of patterns with the first match semantics.
data Patterns (t : T) : Set where
    Œµ‚Çö : Patterns t
    _‚à∑‚Çö_ : Pattern t -> Patterns t -> Patterns t

infixr 6 _‚à∑‚Çö_
infix 5 _‚àã‚Çö‚Çõ_

data Maybe (t : Set) : Set where  -- Useful in intermediate computation.
    Just : t -> Maybe t
    Nothing : Maybe t

-- Defined so that we can use idiom brackets in Agda.
pure : ‚àÄ {t} -> t -> Maybe t
pure = Just

_<*>_ : ‚àÄ {t‚ÇÅ t‚ÇÇ} (f : Maybe (t‚ÇÅ -> t‚ÇÇ)) -> Maybe t‚ÇÅ -> Maybe t‚ÇÇ
(Just f) <*> (Just x) = Just (f x)
_ <*> _ = Nothing

-- ps ‚àã‚Çö‚Çõ q means that the (deep) pattern q is covered by the list ps.
data _‚àã‚Çö‚Çõ_ {t} : Patterns t -> Pattern t -> Set where
    ùï´‚Çö‚Çõ : ‚àÄ {p ps q} -> $Ã∏ q -> p ‚âª‚Çö q -> p ‚à∑‚Çö ps ‚àã‚Çö‚Çõ q
    ùï§‚Çö‚Çõ : ‚àÄ {p ps q} -> ps ‚àã‚Çö‚Çõ q -> p ‚à∑‚Çö ps ‚àã‚Çö‚Çõ q
    -- We allow for failure and eliminate it later.
    ‚òπ‚Çö‚Çõ : ‚àÄ {ps q} -> $Ã∏ q -> ps ‚àã‚Çö‚Çõ q

-- Failure-free version of _‚àã‚Çö‚Çõ_.
data ‚òπÃ∏ {t} : ‚àÄ {ps : Patterns t} {q} -> ps ‚àã‚Çö‚Çõ q -> Set where
    ‚òπÃ∏ùï´ : ‚àÄ {p ps q} {r : $Ã∏ q} {s : p ‚âª‚Çö q} -> ‚òπÃ∏ (ùï´‚Çö‚Çõ {p = p} {ps = ps} r s)
    ‚òπÃ∏ùï§_ : ‚àÄ {p ps q} {r : ps ‚àã‚Çö‚Çõ q} -> ‚òπÃ∏ r -> ‚òπÃ∏ (ùï§‚Çö‚Çõ {p = p} r)

infixr 9 ‚òπÃ∏ùï§_

-- The following functions define the first-match semantics.
coverùï´ : ‚àÄ t (p : Pattern t) -> (‚àÄ q -> $Ã∏ q -> Maybe (p ‚âª‚Çö q))
coverùï´ _ ($ t) q r = Just (‚âª$ q)  -- $ matches everything.
coverùï´ (‚óã A ‚äó B) ‚ü® p‚ÇÅ , p‚ÇÇ ‚ü© ‚ü® q‚ÇÅ , q‚ÇÇ ‚ü© $Ã∏‚ü® r‚ÇÅ , r‚ÇÇ ‚ü©
    with coverùï´ (‚óã A) p‚ÇÅ q‚ÇÅ r‚ÇÅ | coverùï´ (‚óã B) p‚ÇÇ q‚ÇÇ r‚ÇÇ
... | Just c‚ÇÅ | Just c‚ÇÇ = Just ‚âª‚ü® c‚ÇÅ , c‚ÇÇ ‚ü©
... | _       | _       = Nothing
coverùï´ (‚óã A ‚äï B) (œñ‚ÇÅ p) (œñ‚ÇÅ q) ($Ã∏œñ‚ÇÅ r)
    with coverùï´ (‚óã A) p q r
... | Just c  = Just (‚âªœñ‚ÇÅ c)
... | Nothing = Nothing
coverùï´ (‚óã A ‚äï B) (œñ‚ÇÅ p) (œñ‚ÇÇ q) _ = Nothing
coverùï´ (‚óã A ‚äï B) (œñ‚ÇÇ p) (œñ‚ÇÅ q) _ = Nothing
coverùï´ (‚óã A ‚äï B) (œñ‚ÇÇ p) (œñ‚ÇÇ q) ($Ã∏œñ‚ÇÇ r)
    with coverùï´ (‚óã B) p q r
... | Just c  = Just (‚âªœñ‚ÇÇ c)
... | Nothing = Nothing
coverùï´ (‚óè A ‚Öã B) ‚ü™ p‚ÇÅ , p‚ÇÇ ‚ü´ ‚ü™ q‚ÇÅ , q‚ÇÇ ‚ü´ $Ã∏‚ü™ r‚ÇÅ , r‚ÇÇ ‚ü´
    with coverùï´ (‚óè A) p‚ÇÅ q‚ÇÅ r‚ÇÅ | coverùï´ (‚óè B) p‚ÇÇ q‚ÇÇ r‚ÇÇ
... | Just c‚ÇÅ | Just c‚ÇÇ = Just ‚âª‚ü™ c‚ÇÅ , c‚ÇÇ ‚ü´
... | _       | _       = Nothing
coverùï´ (‚óè A & B) (œÄ‚ÇÅ p) (œÄ‚ÇÅ q) ($Ã∏œÄ‚ÇÅ r)
    with coverùï´ (‚óè A) p q r
... | Just c  = Just (‚âªœÄ‚ÇÅ c)
... | Nothing = Nothing
coverùï´ (‚óè A & B) (œÄ‚ÇÅ p) (œÄ‚ÇÇ q) _ = Nothing
coverùï´ (‚óè A & B) (œÄ‚ÇÇ p) (œÄ‚ÇÅ q) _ = Nothing
coverùï´ (‚óè A & B) (œÄ‚ÇÇ p) (œÄ‚ÇÇ q) ($Ã∏œÄ‚ÇÇ r)
    with coverùï´ (‚óè B) p q r
... | Just c  = Just (‚âªœÄ‚ÇÇ c)
... | Nothing = Nothing
coverùï´ (‚óã ‚Üë A‚Å∫) (‚áë A‚Å∫) (‚áë .A‚Å∫) $Ã∏‚áë = Just ‚âª‚áë
coverùï´ (‚óè ‚Üì A‚Åª) (‚áì A‚Åª) (‚áì .A‚Åª) $Ã∏‚áì = Just ‚âª‚áì
coverùï´ (‚óã ¬¨‚Å∫ A‚Å∫) (‚óè‚Å∫ A‚Å∫) (‚óè‚Å∫ .A‚Å∫) $Ã∏‚óè‚Å∫ = Just ‚âª‚óè‚Å∫
coverùï´ (‚óè ¬¨‚Åª A‚Åª) (‚óè‚Åª A‚Åª) (‚óè‚Åª .A‚Åª) $Ã∏‚óè‚Åª = Just ‚âª‚óè‚Åª
coverùï´ (‚óã ùüô) *ÃÇ *ÃÇ $Ã∏*ÃÇ = Just ‚âª*ÃÇ
coverùï´ (‚óè ‚ä•) *Ã¨ *Ã¨ $Ã∏*Ã¨ = Just ‚âª*Ã¨
coverùï´ _ _ _ r = Nothing

coverùï§ : ‚àÄ t (ps : Patterns t) (p : Pattern t)
    -> (‚àÄ q -> $Ã∏ q -> ps ‚àã‚Çö‚Çõ q) -> (‚àÄ q -> $Ã∏ q -> p ‚à∑‚Çö ps ‚àã‚Çö‚Çõ q)
coverùï§ t ps p c q r with coverùï´ t p q r  -- First match semantics
... | Just c' = ùï´‚Çö‚Çõ r c'
... | _       = ùï§‚Çö‚Çõ (c q r)

computeCoverage : ‚àÄ {t} (ps : Patterns t) -> (‚àÄ q -> $Ã∏ q -> ps ‚àã‚Çö‚Çõ q)
computeCoverage Œµ‚Çö q = ‚òπ‚Çö‚Çõ
computeCoverage (x ‚à∑‚Çö ps) = coverùï§ _ ps x (computeCoverage ps)

record Covers (t : T) (ps : Patterns t) : Set where
    constructor ‚ò∫
    field
        ‚ò∫ : (‚àÄ q r -> ‚òπÃ∏ (computeCoverage ps q r))

-- Test out the notorious "majority" function pattern
-- The pattern is complete, but you cannot find a natural split variable.
-- The function as written in Agda syntax:
maj : Bool -> Bool -> Bool -> Bool
maj True False x = x
maj False x True = x
maj x True False = x
maj True True True = True
maj False False False = False

-- Some convenient synonyms
pattern ‚ü®_,_,_‚ü© a b c = ‚ü® ‚ü® a , b ‚ü© , c ‚ü©
pattern $Ã∏‚ü®_,_,_‚ü© a b c = $Ã∏‚ü® $Ã∏‚ü® a , b ‚ü© , c ‚ü©

pattern ùï• = œñ‚ÇÇ *ÃÇ
pattern ùïó = œñ‚ÇÅ *ÃÇ

pattern $Ã∏ùï• = $Ã∏œñ‚ÇÇ $Ã∏*ÃÇ
pattern $Ã∏ùïó = $Ã∏œñ‚ÇÅ $Ã∏*ÃÇ

-- The patterns
maj‚Çö‚Çõ : Patterns (‚óã ùüö ‚äó ùüö ‚äó ùüö)
maj‚Çö‚Çõ = ‚ü® ùïó , ùï• , $ _ ‚ü©
    ‚à∑‚Çö ‚ü® ùï• , $ _ , ùïó ‚ü©
    ‚à∑‚Çö ‚ü® $ _ , ùïó , ùï• ‚ü©
    ‚à∑‚Çö ‚ü® ùïó , ùïó , ùïó ‚ü©
    ‚à∑‚Çö ‚ü® ùï• , ùï• , ùï• ‚ü©
    ‚à∑‚Çö Œµ‚Çö

majCovers : Covers (‚óã ùüö ‚äó ùüö ‚äó ùüö) maj‚Çö‚Çõ
majCovers = ‚ò∫ proof
    where
        proof : _  -- A proof that maj covers every case.
        -- Agda succeeded to infer a lot of things, so
        -- we just have to point out which clause covers which case
        proof _ $Ã∏‚ü® $Ã∏ùïó , $Ã∏ùïó , $Ã∏ùïó ‚ü© = ‚òπÃ∏ùï§ ‚òπÃ∏ùï§ ‚òπÃ∏ùï§ ‚òπÃ∏ùï´
        proof _ $Ã∏‚ü® $Ã∏ùï• , $Ã∏ùïó , $Ã∏ùïó ‚ü© = ‚òπÃ∏ùï§ ‚òπÃ∏ùï´
        proof _ $Ã∏‚ü® $Ã∏ùïó , $Ã∏ùï• , $Ã∏ùïó ‚ü© = ‚òπÃ∏ùï´
        proof _ $Ã∏‚ü® $Ã∏ùï• , $Ã∏ùï• , $Ã∏ùïó ‚ü© = ‚òπÃ∏ùï§ ‚òπÃ∏ùï´
        proof _ $Ã∏‚ü® $Ã∏ùïó , $Ã∏ùïó , $Ã∏ùï• ‚ü© = ‚òπÃ∏ùï§ ‚òπÃ∏ùï§ ‚òπÃ∏ùï´
        proof _ $Ã∏‚ü® $Ã∏ùï• , $Ã∏ùïó , $Ã∏ùï• ‚ü© = ‚òπÃ∏ùï§ ‚òπÃ∏ùï§ ‚òπÃ∏ùï´
        proof _ $Ã∏‚ü® $Ã∏ùïó , $Ã∏ùï• , $Ã∏ùï• ‚ü© = ‚òπÃ∏ùï´
        proof _ $Ã∏‚ü® $Ã∏ùï• , $Ã∏ùï• , $Ã∏ùï• ‚ü© = ‚òπÃ∏ùï§ ‚òπÃ∏ùï§ ‚òπÃ∏ùï§ ‚òπÃ∏ùï§ ‚òπÃ∏ùï´

-- Since we are dealing with linear type theory,
-- We need to take care of variable use.
-- Traditionally, the rules are presented with
-- contexts as lists. Then we invent a 'disjoint union' ‚äé concept
-- to state the rules e.g.
-- Œì ‚ä¢ t : A      Œì' ‚ä¢ s : B
-------------------------------
--   Œì ‚äé Œì' ‚ä¢ (t,s) : A √ó B
-- This requires an awful lot of shifting. We take a much simpler approach:
-- We record all the variables, but mark some of them as used. So Œì and Œì'
-- have the same structure, except that the variable usages are marked differently.
-- ‚äé is then just a straightforward computation.

data Occur : ‚àÄ {t} -> Pattern t -> Set where
    ‚ü®_,_‚ü©‚Çí : ‚àÄ {A‚Å∫ B‚Å∫} {p : Pattern (‚óã A‚Å∫)} {q : Pattern (‚óã B‚Å∫)}
        -> Occur p -> Occur q -> Occur ‚ü® p , q ‚ü©
    œñ‚ÇÅ‚Çí : ‚àÄ {A‚Å∫ B‚Å∫} {p : Pattern (‚óã A‚Å∫)}
        -> Occur p -> Occur (œñ‚ÇÅ {B‚Å∫ = B‚Å∫} p)
    œñ‚ÇÇ‚Çí : ‚àÄ {A‚Å∫ B‚Å∫} {p : Pattern (‚óã B‚Å∫)} 
        -> Occur p -> Occur (œñ‚ÇÇ {A‚Å∫ = A‚Å∫} p)
    ‚ü™_,_‚ü´‚Çí : ‚àÄ {A‚Åª B‚Åª} {p : Pattern (‚óè A‚Åª)} {q : Pattern (‚óè B‚Åª)}
        -> Occur p -> Occur q -> Occur ‚ü™ p , q ‚ü´
    œÄ‚ÇÅ‚Çí : ‚àÄ {A‚Åª B‚Åª} {p : Pattern (‚óè A‚Åª)}
        -> Occur p -> Occur (œÄ‚ÇÅ {B‚Åª = B‚Åª} p)
    œÄ‚ÇÇ‚Çí : ‚àÄ {A‚Åª B‚Åª} {p : Pattern (‚óè B‚Åª)}
        -> Occur p -> Occur (œÄ‚ÇÇ {A‚Åª = A‚Åª} p)
    *ÃÇ‚Çí : Occur *ÃÇ
    *Ã¨‚Çí : Occur *Ã¨
    -- ‚ñ† means it is used; ‚ñ° means it is not used
    -- Basically, treat ‚ñ° as if it is not there
    -- We keep it only because we want to respect the structure of patterns
    -- Otherwise we might as well just flatten the ‚ñ† variables into a list
    ‚ñ†‚áë‚Çí : ‚àÄ {A‚Å∫} -> Occur (‚áë A‚Å∫)
    ‚ñ°‚áë‚Çí : ‚àÄ {A‚Å∫} -> Occur (‚áë A‚Å∫)
    ‚ñ†‚áì‚Çí : ‚àÄ {A‚Åª} -> Occur (‚áì A‚Åª)
    ‚ñ°‚áì‚Çí : ‚àÄ {A‚Åª} -> Occur (‚áì A‚Åª)
    ‚ñ†‚óè‚Å∫‚Çí : ‚àÄ {A‚Å∫} -> Occur (‚óè‚Å∫ A‚Å∫)
    ‚ñ°‚óè‚Å∫‚Çí : ‚àÄ {A‚Å∫} -> Occur (‚óè‚Å∫ A‚Å∫)
    ‚ñ†‚óè‚Åª‚Çí : ‚àÄ {A‚Åª} -> Occur (‚óè‚Åª A‚Åª)
    ‚ñ°‚óè‚Åª‚Çí : ‚àÄ {A‚Åª} -> Occur (‚óè‚Åª A‚Åª)
    ‚ñ†$‚Çí : ‚àÄ {t} -> Occur ($ t)
    ‚ñ°$‚Çí : ‚àÄ {t} -> Occur ($ t)

-- Auxiliary functions to construct occurrences
‚ñ° : ‚àÄ {t} -> (p : Pattern t) -> Occur p
‚ñ° ‚ü® p , q ‚ü© = ‚ü® ‚ñ° p , ‚ñ° q ‚ü©‚Çí
‚ñ° (œñ‚ÇÅ p) = œñ‚ÇÅ‚Çí (‚ñ° p)
‚ñ° (œñ‚ÇÇ p) = œñ‚ÇÇ‚Çí (‚ñ° p)
‚ñ° ‚ü™ p , q ‚ü´ = ‚ü™ ‚ñ° p , ‚ñ° q ‚ü´‚Çí
‚ñ° (œÄ‚ÇÅ p) = œÄ‚ÇÅ‚Çí (‚ñ° p)
‚ñ° (œÄ‚ÇÇ p) = œÄ‚ÇÇ‚Çí (‚ñ° p)
‚ñ° *ÃÇ = *ÃÇ‚Çí
‚ñ° *Ã¨ = *Ã¨‚Çí
‚ñ° (‚áë A‚Å∫) = ‚ñ°‚áë‚Çí
‚ñ° (‚áì A‚Åª) = ‚ñ°‚áì‚Çí
‚ñ° (‚óè‚Å∫ A‚Å∫) = ‚ñ°‚óè‚Å∫‚Çí
‚ñ° (‚óè‚Åª A‚Åª) = ‚ñ°‚óè‚Åª‚Çí
‚ñ° ($ _) = ‚ñ°$‚Çí

‚ñ† : ‚àÄ {t} -> (p : Pattern t) -> Occur p
‚ñ† ‚ü® p , q ‚ü© = ‚ü® ‚ñ† p , ‚ñ† q ‚ü©‚Çí
‚ñ† (œñ‚ÇÅ p) = œñ‚ÇÅ‚Çí (‚ñ† p)
‚ñ† (œñ‚ÇÇ p) = œñ‚ÇÇ‚Çí (‚ñ† p)
‚ñ† ‚ü™ p , q ‚ü´ = ‚ü™ ‚ñ† p , ‚ñ† q ‚ü´‚Çí
‚ñ† (œÄ‚ÇÅ p) = œÄ‚ÇÅ‚Çí (‚ñ† p)
‚ñ† (œÄ‚ÇÇ p) = œÄ‚ÇÇ‚Çí (‚ñ† p)
‚ñ† *ÃÇ = *ÃÇ‚Çí
‚ñ† *Ã¨ = *Ã¨‚Çí
‚ñ† (‚áë A‚Å∫) = ‚ñ†‚áë‚Çí
‚ñ† (‚áì A‚Åª) = ‚ñ†‚áì‚Çí
‚ñ† (‚óè‚Å∫ A‚Å∫) = ‚ñ†‚óè‚Å∫‚Çí
‚ñ† (‚óè‚Åª A‚Åª) = ‚ñ†‚óè‚Åª‚Çí
‚ñ† ($ _) = ‚ñ†$‚Çí

-- Marks the one variable in the pattern indicated by (p ‚àã‚Çö t')
‚ñ†‚àã‚Çö : ‚àÄ {t t'} {p : Pattern t} -> (p ‚àã‚Çö t') -> Occur p
‚ñ†‚àã‚Çö ‚ü® Œ± ,~‚ü© = ‚ü® ‚ñ†‚àã‚Çö Œ± , ‚ñ° _ ‚ü©‚Çí
‚ñ†‚àã‚Çö ‚ü®~, Œ± ‚ü© = ‚ü® ‚ñ° _ , ‚ñ†‚àã‚Çö Œ± ‚ü©‚Çí
‚ñ†‚àã‚Çö (~œñ‚ÇÅ Œ±) = œñ‚ÇÅ‚Çí (‚ñ†‚àã‚Çö Œ±)
‚ñ†‚àã‚Çö (~œñ‚ÇÇ Œ±) = œñ‚ÇÇ‚Çí (‚ñ†‚àã‚Çö Œ±)
‚ñ†‚àã‚Çö ‚ü™ Œ± ,~‚ü´ = ‚ü™ ‚ñ†‚àã‚Çö Œ± , ‚ñ° _ ‚ü´‚Çí
‚ñ†‚àã‚Çö ‚ü™~, Œ± ‚ü´ = ‚ü™ ‚ñ° _ , ‚ñ†‚àã‚Çö Œ± ‚ü´‚Çí
‚ñ†‚àã‚Çö (~œÄ‚ÇÅ Œ±) = œÄ‚ÇÅ‚Çí (‚ñ†‚àã‚Çö Œ±)
‚ñ†‚àã‚Çö (~œÄ‚ÇÇ Œ±) = œÄ‚ÇÇ‚Çí (‚ñ†‚àã‚Çö Œ±)
‚ñ†‚àã‚Çö ~‚áë = ‚ñ†‚áë‚Çí
‚ñ†‚àã‚Çö ~‚áì = ‚ñ†‚áì‚Çí
‚ñ†‚àã‚Çö ~‚óè‚Å∫ = ‚ñ†‚óè‚Å∫‚Çí
‚ñ†‚àã‚Çö ~‚óè‚Åª = ‚ñ†‚óè‚Åª‚Çí
‚ñ†‚àã‚Çö ~$ = ‚ñ†$‚Çí

-- A type certificate that two occurrences are disjoint
data _‚äé_‚âÖ_ : ‚àÄ {t} {p : Pattern t} -> Occur p -> Occur p -> Occur p -> Set where
    ‚äé‚ü®_,_‚ü© : ‚àÄ {A B} {p : Pattern (‚óã A)} {q : Pattern (‚óã B)}
        -> {Œî‚ÇÅ Œî‚ÇÇ Œî‚ÇÉ : Occur p} {Œî'‚ÇÅ Œî'‚ÇÇ Œî'‚ÇÉ : Occur q}
        -> Œî‚ÇÅ ‚äé Œî‚ÇÇ ‚âÖ Œî‚ÇÉ -> Œî'‚ÇÅ ‚äé Œî'‚ÇÇ ‚âÖ Œî'‚ÇÉ -> ‚ü® Œî‚ÇÅ , Œî'‚ÇÅ ‚ü©‚Çí ‚äé ‚ü® Œî‚ÇÇ , Œî'‚ÇÇ ‚ü©‚Çí ‚âÖ ‚ü® Œî‚ÇÉ , Œî'‚ÇÉ ‚ü©‚Çí
    ‚äéœñ‚ÇÅ : ‚àÄ {A B} {p : Pattern (‚óã A)}
        -> {Œî‚ÇÅ Œî‚ÇÇ Œî‚ÇÉ : Occur p}
        -> Œî‚ÇÅ ‚äé Œî‚ÇÇ ‚âÖ Œî‚ÇÉ -> œñ‚ÇÅ‚Çí Œî‚ÇÅ ‚äé œñ‚ÇÅ‚Çí Œî‚ÇÇ ‚âÖ œñ‚ÇÅ‚Çí {B‚Å∫ = B} Œî‚ÇÉ
    ‚äéœñ‚ÇÇ : ‚àÄ {A B} {p : Pattern (‚óã B)}
        -> {Œî‚ÇÅ Œî‚ÇÇ Œî‚ÇÉ : Occur p}
        -> Œî‚ÇÅ ‚äé Œî‚ÇÇ ‚âÖ Œî‚ÇÉ -> œñ‚ÇÇ‚Çí Œî‚ÇÅ ‚äé œñ‚ÇÇ‚Çí Œî‚ÇÇ ‚âÖ œñ‚ÇÇ‚Çí {A‚Å∫ = A} Œî‚ÇÉ
    ‚äé‚ü™_,_‚ü´ : ‚àÄ {A B} {p : Pattern (‚óè A)} {q : Pattern (‚óè B)}
        -> {Œî‚ÇÅ Œî‚ÇÇ Œî‚ÇÉ : Occur p} {Œî'‚ÇÅ Œî'‚ÇÇ Œî'‚ÇÉ : Occur q}
        -> Œî‚ÇÅ ‚äé Œî‚ÇÇ ‚âÖ Œî‚ÇÉ -> Œî'‚ÇÅ ‚äé Œî'‚ÇÇ ‚âÖ Œî'‚ÇÉ -> ‚ü™ Œî‚ÇÅ , Œî'‚ÇÅ ‚ü´‚Çí ‚äé ‚ü™ Œî‚ÇÇ , Œî'‚ÇÇ ‚ü´‚Çí ‚âÖ ‚ü™ Œî‚ÇÉ , Œî'‚ÇÉ ‚ü´‚Çí
    ‚äéœÄ‚ÇÅ : ‚àÄ {A B} {p : Pattern (‚óè A)}
        -> {Œî‚ÇÅ Œî‚ÇÇ Œî‚ÇÉ : Occur p}
        -> Œî‚ÇÅ ‚äé Œî‚ÇÇ ‚âÖ Œî‚ÇÉ -> œÄ‚ÇÅ‚Çí Œî‚ÇÅ ‚äé œÄ‚ÇÅ‚Çí Œî‚ÇÇ ‚âÖ œÄ‚ÇÅ‚Çí {B‚Åª = B} Œî‚ÇÉ
    ‚äéœÄ‚ÇÇ : ‚àÄ {A B} {p : Pattern (‚óè B)}
        -> {Œî‚ÇÅ Œî‚ÇÇ Œî‚ÇÉ : Occur p}
        -> Œî‚ÇÅ ‚äé Œî‚ÇÇ ‚âÖ Œî‚ÇÉ -> œÄ‚ÇÇ‚Çí Œî‚ÇÅ ‚äé œÄ‚ÇÇ‚Çí Œî‚ÇÇ ‚âÖ œÄ‚ÇÇ‚Çí {A‚Åª = A} Œî‚ÇÉ
    ‚äé*ÃÇ : *ÃÇ‚Çí ‚äé *ÃÇ‚Çí ‚âÖ *ÃÇ‚Çí
    ‚äé*Ã¨ : *Ã¨‚Çí ‚äé *Ã¨‚Çí ‚âÖ *Ã¨‚Çí
    ‚äé‚áë‚ñ° : ‚àÄ {A} -> ‚ñ°‚áë‚Çí ‚äé ‚ñ°‚áë‚Çí ‚âÖ ‚ñ°‚áë‚Çí {A‚Å∫ = A}
    ‚äé‚áëL : ‚àÄ {A} -> ‚ñ†‚áë‚Çí ‚äé ‚ñ°‚áë‚Çí ‚âÖ ‚ñ†‚áë‚Çí {A‚Å∫ = A}
    ‚äé‚áëR : ‚àÄ {A} -> ‚ñ°‚áë‚Çí ‚äé ‚ñ†‚áë‚Çí ‚âÖ ‚ñ†‚áë‚Çí {A‚Å∫ = A}
    ‚äé‚áì‚ñ° : ‚àÄ {A} -> ‚ñ°‚áì‚Çí ‚äé ‚ñ°‚áì‚Çí ‚âÖ ‚ñ°‚áì‚Çí {A‚Åª = A}
    ‚äé‚áìL : ‚àÄ {A} -> ‚ñ†‚áì‚Çí ‚äé ‚ñ°‚áì‚Çí ‚âÖ ‚ñ†‚áì‚Çí {A‚Åª = A}
    ‚äé‚áìR : ‚àÄ {A} -> ‚ñ°‚áì‚Çí ‚äé ‚ñ†‚áì‚Çí ‚âÖ ‚ñ†‚áì‚Çí {A‚Åª = A}
    ‚äé‚óè‚Å∫‚ñ° : ‚àÄ {A} -> ‚ñ°‚óè‚Å∫‚Çí ‚äé ‚ñ°‚óè‚Å∫‚Çí ‚âÖ ‚ñ°‚óè‚Å∫‚Çí {A‚Å∫ = A}
    ‚äé‚óè‚Å∫L : ‚àÄ {A} -> ‚ñ†‚óè‚Å∫‚Çí ‚äé ‚ñ°‚óè‚Å∫‚Çí ‚âÖ ‚ñ†‚óè‚Å∫‚Çí {A‚Å∫ = A}
    ‚äé‚óè‚Å∫R : ‚àÄ {A} -> ‚ñ°‚óè‚Å∫‚Çí ‚äé ‚ñ†‚óè‚Å∫‚Çí ‚âÖ ‚ñ†‚óè‚Å∫‚Çí {A‚Å∫ = A}
    ‚äé‚óè‚Åª‚ñ° : ‚àÄ {A} -> ‚ñ°‚óè‚Åª‚Çí ‚äé ‚ñ°‚óè‚Åª‚Çí ‚âÖ ‚ñ°‚óè‚Åª‚Çí {A‚Åª = A}
    ‚äé‚óè‚ÅªL : ‚àÄ {A} -> ‚ñ†‚óè‚Åª‚Çí ‚äé ‚ñ°‚óè‚Åª‚Çí ‚âÖ ‚ñ†‚óè‚Åª‚Çí {A‚Åª = A}
    ‚äé‚óè‚ÅªR : ‚àÄ {A} -> ‚ñ°‚óè‚Åª‚Çí ‚äé ‚ñ†‚óè‚Åª‚Çí ‚âÖ ‚ñ†‚óè‚Åª‚Çí {A‚Åª = A}
    ‚äé$‚ñ° : ‚àÄ {t} -> ‚ñ°$‚Çí ‚äé ‚ñ°$‚Çí ‚âÖ ‚ñ°$‚Çí {t = t}
    ‚äé$L : ‚àÄ {t} -> ‚ñ†$‚Çí ‚äé ‚ñ°$‚Çí ‚âÖ ‚ñ†$‚Çí {t = t}
    ‚äé$R : ‚àÄ {t} -> ‚ñ°$‚Çí ‚äé ‚ñ†$‚Çí ‚âÖ ‚ñ†$‚Çí {t = t}

-- Of course, it is decidable.
-- We need dependent pairs, but let's not introduce yet another mixfix.

data Exists (A : Set) (B : A -> Set) : Set where
    exists : ‚àÄ (a : A) (b : B a) -> Exists A B

-- aux functions that have awful type signatures
-- basically just the product morphism:
-- (f √ó g) (x, y) = (f(x), g(y))
-- But we have dependent types. A mundane dependent type exercise.
pair : ‚àÄ {A B A' B'} -> (f : A -> A') -> (‚àÄ {a} -> B a -> B' (f a))
    -> (Exists A B -> Exists A' B')
pair f g (exists a b) = exists (f a) (g {a} b)

-- A 2-adic version.
pair¬≤ : ‚àÄ {A‚ÇÅ A‚ÇÇ A B‚ÇÅ B‚ÇÇ B} -> (f : A‚ÇÅ -> A‚ÇÇ -> A) -> (‚àÄ {a‚ÇÅ a‚ÇÇ} -> B‚ÇÅ a‚ÇÅ -> B‚ÇÇ a‚ÇÇ -> B (f a‚ÇÅ a‚ÇÇ))
    -> (Exists A‚ÇÅ B‚ÇÅ -> Exists A‚ÇÇ B‚ÇÇ -> Exists A B)
pair¬≤ f g (exists a‚ÇÅ b‚ÇÅ) (exists a‚ÇÇ b‚ÇÇ) = exists (f a‚ÇÅ a‚ÇÇ) (g b‚ÇÅ b‚ÇÇ)

-- We implement the decision procedure.
-- It doesn't explain why it fails, but always carries a proof when it succeeds.
_‚äé_ : ‚àÄ {t} {p : Pattern t} -> (Œî‚ÇÅ Œî‚ÇÇ : Occur p) -> Maybe (Exists _ \Œî -> Œî‚ÇÅ ‚äé Œî‚ÇÇ ‚âÖ Œî)
‚ü® Œî‚ÇÅ , Œî‚ÇÉ ‚ü©‚Çí ‚äé ‚ü® Œî‚ÇÇ , Œî‚ÇÑ ‚ü©‚Çí = ‚¶á (pair¬≤ ‚ü®_,_‚ü©‚Çí ‚äé‚ü®_,_‚ü©) (Œî‚ÇÅ ‚äé Œî‚ÇÇ) (Œî‚ÇÉ ‚äé Œî‚ÇÑ) ‚¶à
œñ‚ÇÅ‚Çí Œî‚ÇÅ ‚äé œñ‚ÇÅ‚Çí Œî‚ÇÇ = ‚¶á (pair œñ‚ÇÅ‚Çí ‚äéœñ‚ÇÅ) (Œî‚ÇÅ ‚äé Œî‚ÇÇ) ‚¶à
œñ‚ÇÇ‚Çí Œî‚ÇÅ ‚äé œñ‚ÇÇ‚Çí Œî‚ÇÇ = ‚¶á (pair œñ‚ÇÇ‚Çí ‚äéœñ‚ÇÇ) (Œî‚ÇÅ ‚äé Œî‚ÇÇ) ‚¶à
‚ü™ Œî‚ÇÅ , Œî‚ÇÉ ‚ü´‚Çí ‚äé ‚ü™ Œî‚ÇÇ , Œî‚ÇÑ ‚ü´‚Çí = ‚¶á (pair¬≤ ‚ü™_,_‚ü´‚Çí ‚äé‚ü™_,_‚ü´) (Œî‚ÇÅ ‚äé Œî‚ÇÇ) (Œî‚ÇÉ ‚äé Œî‚ÇÑ) ‚¶à
œÄ‚ÇÅ‚Çí Œî‚ÇÅ ‚äé œÄ‚ÇÅ‚Çí Œî‚ÇÇ = ‚¶á (pair œÄ‚ÇÅ‚Çí ‚äéœÄ‚ÇÅ) (Œî‚ÇÅ ‚äé Œî‚ÇÇ) ‚¶à
œÄ‚ÇÇ‚Çí Œî‚ÇÅ ‚äé œÄ‚ÇÇ‚Çí Œî‚ÇÇ = ‚¶á (pair œÄ‚ÇÇ‚Çí ‚äéœÄ‚ÇÇ) (Œî‚ÇÅ ‚äé Œî‚ÇÇ) ‚¶à
*ÃÇ‚Çí ‚äé *ÃÇ‚Çí = Just (exists *ÃÇ‚Çí ‚äé*ÃÇ)
*Ã¨‚Çí ‚äé *Ã¨‚Çí = Just (exists *Ã¨‚Çí ‚äé*Ã¨)
‚ñ†‚áë‚Çí ‚äé ‚ñ†‚áë‚Çí = Nothing
‚ñ†‚áë‚Çí ‚äé ‚ñ°‚áë‚Çí = Just (exists ‚ñ†‚áë‚Çí ‚äé‚áëL)
‚ñ°‚áë‚Çí ‚äé ‚ñ†‚áë‚Çí = Just (exists ‚ñ†‚áë‚Çí ‚äé‚áëR)
‚ñ°‚áë‚Çí ‚äé ‚ñ°‚áë‚Çí = Just (exists ‚ñ°‚áë‚Çí ‚äé‚áë‚ñ°)
‚ñ†‚áì‚Çí ‚äé ‚ñ†‚áì‚Çí = Nothing
‚ñ†‚áì‚Çí ‚äé ‚ñ°‚áì‚Çí = Just (exists ‚ñ†‚áì‚Çí ‚äé‚áìL)
‚ñ°‚áì‚Çí ‚äé ‚ñ†‚áì‚Çí = Just (exists ‚ñ†‚áì‚Çí ‚äé‚áìR)
‚ñ°‚áì‚Çí ‚äé ‚ñ°‚áì‚Çí = Just (exists ‚ñ°‚áì‚Çí ‚äé‚áì‚ñ°)
‚ñ†‚óè‚Å∫‚Çí ‚äé ‚ñ†‚óè‚Å∫‚Çí = Nothing
‚ñ†‚óè‚Å∫‚Çí ‚äé ‚ñ°‚óè‚Å∫‚Çí = Just (exists ‚ñ†‚óè‚Å∫‚Çí ‚äé‚óè‚Å∫L)
‚ñ°‚óè‚Å∫‚Çí ‚äé ‚ñ†‚óè‚Å∫‚Çí = Just (exists ‚ñ†‚óè‚Å∫‚Çí ‚äé‚óè‚Å∫R)
‚ñ°‚óè‚Å∫‚Çí ‚äé ‚ñ°‚óè‚Å∫‚Çí = Just (exists ‚ñ°‚óè‚Å∫‚Çí ‚äé‚óè‚Å∫‚ñ°)
‚ñ†‚óè‚Åª‚Çí ‚äé ‚ñ†‚óè‚Åª‚Çí = Nothing
‚ñ†‚óè‚Åª‚Çí ‚äé ‚ñ°‚óè‚Åª‚Çí = Just (exists ‚ñ†‚óè‚Åª‚Çí ‚äé‚óè‚ÅªL)
‚ñ°‚óè‚Åª‚Çí ‚äé ‚ñ†‚óè‚Åª‚Çí = Just (exists ‚ñ†‚óè‚Åª‚Çí ‚äé‚óè‚ÅªR)
‚ñ°‚óè‚Åª‚Çí ‚äé ‚ñ°‚óè‚Åª‚Çí = Just (exists ‚ñ°‚óè‚Åª‚Çí ‚äé‚óè‚Åª‚ñ°)
‚ñ†$‚Çí ‚äé ‚ñ†$‚Çí = Nothing
‚ñ†$‚Çí ‚äé ‚ñ°$‚Çí = Just (exists ‚ñ†$‚Çí ‚äé$L)
‚ñ°$‚Çí ‚äé ‚ñ†$‚Çí = Just (exists ‚ñ†$‚Çí ‚äé$R)
‚ñ°$‚Çí ‚äé ‚ñ°$‚Çí = Just (exists ‚ñ°$‚Çí ‚äé$‚ñ°)

infixr 6 _‚äé_
